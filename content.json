[{"title":"使用Hexo，如何在多台电脑上维护和更新github pages博客","date":"2017-03-23T14:51:40.000Z","path":"2017/03/23/hexo-github-pages/","text":"今天在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章、更新博客，该怎么办呢？一个想法很快跳了出来： 只要把公司本地博客根目录存着的source/_posts（文章所在目录）、_config.yml（博客配置文件）以及themes（主题文件目录）都备份一份（多种方式备份：使用U盘、网盘、GitHub仓库），待回到家之后重新hexo init，然后将备份的文件覆盖进去，再hexo d -g，即可完成博客在另一台电脑的克隆。 然而，这种方式的缺点也很明显，即多次备份，以使用U盘备份为例： 我在公司写了文章A并发布（deploy），到家后如果写了文章B，这时不能直接发布博客，因为家里的本地是没有文章A的，这时发布会造成博客上已发布的文章A丢失，因此就需要把文章A的备份拷进去；好，那就把备份拷进去，然后hexo d -g，OK，新文章B上去了,已发布的文章A也没丢。 到上面为止，一切都还能接受。 但如果我第二天在公司上班突然来了灵感，利用业余时间在公司写了文章C呢？我需要重复第一步，把备份的文章B拷到公司本地的博客文章目录中，然后重复…… 上面的例子是使用U盘备份，是一个比较极端的例子。更好的方法是新建另一个GitHub仓库保存备份整个hexo博客文件夹，每次更新不需要把U盘带来带去，也不需要ctrl+c、ctrl+v，而只需要git pull、git push，相当于每次在该仓库的最新版本上对博客进行维护更新，产生的新改动会在hexo d -g后于个人博客仓库生效。 作为一名程序员，优雅应当是天性，即使使用另一个GitHub仓库进行备份我依然觉得不够优雅，能不能只在个人博客仓库上面就做到满足这个场景呢？ 于是我开始搜索资料，搜到了一个符合当前场景的解决方案，然而，试了该方案后，我悲哀的发现，这个解决方案已经过时了，不再符合当前的hexo版本[注解1]。 但是，天无绝人之路，方案不能全盘照搬，但是核心思想却是可行的，我的思路一下子被打开了——可以使用git分支来解决！使用个人博客仓库的master分支来保存博客静态页面，使用另一个分支来保存hexo部署目录！ 话不多说，下面是我实践的方法： 一、准备工作开始本教程之前，请确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录（博客根目录）： 如果这一步还未完成，请自行搜索如何使用hexo搭建Github Pages个人博客，网上教程一大堆，不再赘述。 二、对username.github.io仓库新建分支，并克隆有两种方式： 先把username.github.io克隆到本地（不在hexo博客部署环境目录中，另起一个），然后进入username.github.io文件目录，在Git Bash中执行git branch xxx命令新建xxx分支，再使用git checkout xxx切换到该分支； 先在Github上可视化新建xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆到本地，并进入该username.github.io文件目录。 上面两种方式只是顺序的差异，本质上没有区别，我采用的是后者。 完成上面步骤后，在当前目录使用git branch命令查看当前所在分支，应为新建的分支xxx： 12git branch* xxx 三、将本地博客的部署文件拷贝进username.github.io文件目录如题，先将本地博客的部署文件拷贝进username.github.io文件目录。 接下来，将拷贝进来的博客hexo部署环境提交到xxx分支，提交之前需注意： 将.gitignore文件中的db.json、.deploy*/两行删去，保证这两个文件都能同步到仓库xxx分支上。 再将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 四、提交xxx分支，并发布博客在username.github.io目录使用Git Bash执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push origin xxx即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支了。 这时，博客的更新还没生效，因为master分支并没有发生变化。继续执行hexo d -g指令，完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 五、新电脑环境部署至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地 在以上目录执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下) 写新文章 执行本教程第四步：提交xxx分支，并发布博客 下次回到原来的电脑，再也不需要备份和拷贝了，只需要一次git pull origin xxx更新一下新电脑推送的最新版本，即可继续同步维护更新！ master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！ 六、更加完美：设置默认分支以上已经很完美了，但还不够尽善尽美！ 因为我们平时更新博客，并不需要手动在master分支上进行git操作，只需要hexo d -g一把，即可完成博客更新。 也就是说，我们是不会用到master分支的，那就可以把每次git push origin xxx和git pull origin xxx中的分支origin xxx省去，直接将xxx设为默认分支，即只使用git push和git pull指令，多么令人愉悦的操作！ 那么如何设置默认分支呢？ [注解1]：我百度到的旧版本解决方案见：使用hexo，如果换了电脑怎么更新博客？，有兴趣可以看看","tags":[{"name":"hexo","slug":"hexo","permalink":"https://pilgrimerick.github.io/tags/hexo/"}]},{"title":"【转载】JavaScript：彻底理解同步、异步和事件循环(Event Loop)","date":"2017-03-23T07:07:07.000Z","path":"2017/03/23/js-event-loop/","text":"一. 单线程我们常说“JavaScript是单线程的”。 所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。 但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。 二. 同步和异步假设存在一个函数A：1A(args...); 同步：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 例如： 12Math.sqrt(2);console.log('Hi'); 第一个函数返回时，就拿到了预期的返回值：2的平方根。 第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。 所以这两个函数都是同步的。 异步：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 例如：123fs.readFile('foo.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;); 在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。 下面以AJAX请求为例，来看一下同步和异步的区别： 异步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“……” 主线程：：“喂，AJAX线程，你怎么不说话？” AJAX线程：“……” 主线程：：“喂！喂喂喂！” AJAX线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。异步是这篇文章关注的重点。 三. 异步过程的构成要素从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。 总结一下，一个异步过程通常是这样的： 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。 异步函数通常具有以下的形式： 1A(args..., callbackFn) 它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。args是这个函数需要的参数。callbackFn也是这个函数的参数，但是它比较特殊所以单独列出来。 所以，从主线程的角度看，一个异步过程包括下面两个要素： 发起函数(或叫注册函数)A 回调函数callbackFn 它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。 举个具体的例子： 1setTimeout(fn, 1000); 其中的setTimeout就是异步过程的发起函数，fn是回调函数。 注意：前面说的形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如： 1234var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open('GET', url);xhr.send(); // 发起函数 发起函数和回调函数就是分离的。 四. 消息队列和事件循环上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制是怎样实现的呢？答案是利用消息队列和事件循环。 用一句话概括： *工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 事件循环用代码表示大概是这样的： 1234while(true) &#123; var message = queue.get(); execute(message);&#125; 那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为： 消息就是注册异步任务时添加的回调函数。再次以异步AJAX为例，假设存在如下的代码： 12345678$.ajax('http://segmentfault.com', function(resp) &#123; console.log('我是响应：', resp);&#125;);// 其他代码......... 主线程在发起AJAX请求后，会继续执行其他代码。AJAX线程负责请求segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息： 1234// 消息队列中的消息就长这个样子var message = function () &#123; callbackFn(response);&#125; 其中的callbackFn就是前面代码中得到成功响应时的回调函数。 主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。 用图表示这个过程就是： 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 五. 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。 举例来说： 1234var button = document.getElement('#btn');button.addEventListener('click', function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout可以看成对应一个时间到了！的事件。前文的setTimeout(fn, 1000);可以看成： 1timer.addEventListener('timeout', 1000, fn); 六. 生产者与消费者从生产者与消费者的角度看，异步过程是这样的： 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 七. 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 :) PS：ECMAScript 262规范中，并没有对异步、事件队列等概念及其实现的描述。这些都是具体的JavaScript运行时环境使用的机制。本文重点是描述异步过程的原理，为了便于理解做了很多简化。所以文中的某些术语的使用可能是不准确的，具体细节也未必是正确的，例如消息队列中消息的结构。请读者注意。 PS:本文转载自 https://segmentfault.com/a/1190000004322358","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://pilgrimerick.github.io/tags/Javascript/"},{"name":"笔记","slug":"笔记","permalink":"https://pilgrimerick.github.io/tags/笔记/"}]},{"title":"Hello My World","date":"2017-03-23T04:07:07.000Z","path":"2017/03/23/hello-world/","text":"终于，强迫症尘埃落定，我最终决定个人博客域名就还是让pilgrimErick这个字符串来承担这个重任！！ 我注册了几个github帐号，目的就是为了想要一个合心的github pages域名，然而，最终我还是选择了这个——第一个注册的用户名。 有些卖春的女孩儿这样说：“折腾了大半个青春，该找个老实人嫁了”，我的笔记、我的思维就如同这些放荡的贱人一般，东躺躺西睡睡，如今也该有个落脚的地方了，这几乎完全是我的个人世界，不用受任何外在因素的干扰（除非github倒闭了XD）。 我感到前所未有的自由~~ 然而，我是个懒人，能坚持更新吗？坚持多久呢？嘛，谁也说不清楚，有灵感就会来这儿划上一笔的！","tags":[{"name":"随笔","slug":"随笔","permalink":"https://pilgrimerick.github.io/tags/随笔/"}]}]