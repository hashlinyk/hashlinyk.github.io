[{"title":"前端工程化之Babel入门：了解Babel","date":"2021-12-29T14:05:33.000Z","path":"2021/12/29/前端工程化之Babel入门：了解Babel/","text":"谈到前端工程化，脑海中就会浮现Webpack、Eslint、Babel、Gulp、Rollup等字眼，甚至还有CI/CD（持续集成/持续部署）、自动化测试等高深概念。这篇文章将尝试用最简单的白话来了解Babel的概貌，认识Babel在前端工程流中的角色定位，以及基础用法，为之后的前端工程化深入学习做铺垫。 概貌Babel 是什么？Babel 是一个 JavaScript 编译器。 上面这句话就是Babel的本质，更简单的说，Babel可以把使用ES6/ES7等“高级”语法编写的Javascript代码转换为ES5/ES3的“通俗”语法（也可以把JSX语法转为Javascript）。 随着ECMAScript 标准规范发展越来越快，新语法层出不穷，然而浏览器更新却存在着滞后性，对ECMAScript新标准支持程度不一，Web前端开发者眼巴巴看着各种“高大上”、“简洁”、“实用”的语法和API，却不敢在实际项目中直接使用，以免由于浏览器不兼容导致各种问题，于是Babel诞生了！ 从此以后，我们也可以尽情地使用“高大上”的ES6+高级语法了，只要经过Babel转换，最终输出的代码是啥样的我们不再那么关心，只要浏览器能读懂并执行就行。 也许你会担心经过Babel转换后的代码太过难以阅读，调试起来会非常困难。幸好Babel支持了一个叫做Source map的特性，使我们调试起来也和直接写ES5/ES3代码的调试方式一样简单，而这对我们来说，只需要启用一个配置项就可以做到。 Babel在前端工程流中的角色定位我们知道，如今前端工程流中最耳熟能详的一个词是：Webpack. 现在很多前端项目脚手架都内置依赖了webpack，且提供了一套默认配置，做到开箱即用。我们只需要按照官网文档给出的步骤，一个命令一个命令去执行，如npm run serve、npm run build…，即可实现大部分开发场景需求，在需要定制化的情况下，甚至自己建一个vue.config.js文件去按照文档说明扩展配置即可，不再需要了解webpack的具体用法就能“叱咤Vue界”。 这是前端工程化发展的必然，有句话说得好，“懒人改变世界”，技术的发展造福了更多的懒人。在这样的大背景下，Webpack的细节被隐藏和弱化，更别提Babel了。我们可以在项目看到一个.babelrc文件，却大部分时间都不会注意到它，更别说打开它和编辑它了。 但就是这么一个低存在感的小透明，却承担起了巨大的责任，在背后默默工作，辛苦地把你新编写的ES6 class转换成了平凡的构造函数，在你Ctrl + S之后看到浏览器页面焕然一新的瞬间，你可会想到这个小透明做的事情有多么伟大？当然，这一切也离不开老大哥Webpack的提携，在Webpack的Loader机制下，Babel在这里作为Webpack loader角色的一员勤勤恳恳工作着。 除了作为Webpack loader，Babel当然也能孤军奋战，独当一面，文章后面将介绍Babel单独使用和结合Webpack使用两种用法。 Babel工具集在使用Babel之前，我们先要知道Babel包含哪些东西，是的，它不是一个单一的工具，一开始它确实是一个单一的Javascript转换器，但现在它变成了一个工具集……别慌，它并没有因此变得很复杂，之所以这么设计是有原因的： 在Babel 6以前，Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。 详见Babel 6.0之babel-cli和babel-core的用法和区别 自Babel 7起，Babel团队改用作用域软件包，因此您现在必须使用@babel/core而不是babel-core.但实质上，@babel/core只是babel-core的较新版本。这样做是为了更好地区分哪些软件包是官方软件包，哪些是第三方软件包。 Babel7包含了核心包@babel/core、终端命令行界面工具@babel/cli以及各种语法转换规则包（官方称之为preset，即“预设”）如@babel/preset-env、@babel/preset-react、@babel/preset-typescript、@babel/preset-flow，这些都是按需安装使用的，后面介绍用法时你将了解它们的用途。 在Babel 7之前，存在按年度区分的语法预设包如preset-es2015、preset-es2016、preset-es2017等，从Babel 7开始，Babel团队删除（并停止发布）了任何年度的preset（preset-es2015 等）， @babel/preset-env取代了对这些内容的需求，因为它包含了所有年度所添加内容以及针对特定浏览器集兼容的能力。 Babel工具集还包含一个叫做@babel/polyfill的库，作用是针对ES6+的一些新的内置API使用基础JS语法进行模拟实现，以适用较低版本的浏览器。而@babel/core只做语法（Syntax）转换（如class、箭头函数等），不实现Api polyfill。 polyfill在英文中有垫片的意思，意为兜底的东西。 @babel/polyfill模拟一个完全的 ES2015+ 的环境，实现了新的特性比如 Promise 或者 WeakMap， 静态方法比如Array.from 或 Object.assign, 实例方法 比如 Array.prototype.includes 和 generator 函数。 从babel V7.4.0版本开始，已经不建议使用该包，建议使用core-js/stable、regenerator-runtime/runtime替代。 找个时间另外写一下这块的细节，可以先查阅官网文档@babel/polyfill 除此之外，这里简单提一下Babel插件（Plugin）的概念，不做深入。在Babel中，代码转换功能以插件的形式出现，插件是小型的 JavaScript 程序，用于指导 Babel 如何对代码进行转换。你甚至可以编写自己的插件将你所需要的任何代码转换功能应用到你的代码上。Babel插件分为语法插件和转换插件两种： 语法插件：大多数语法都可以被 Babel 转换。在极少数情况下（如果转换还没有实现，或者没有默认的方式来实现），你可以使用语法插件，例如@babel/plugin-syntax-bigint只允许 Babel解析特定类型的语法。 转换插件：转换您的代码，转换插件将启用相应的语法插件，因此您不必同时指定两者。 实际上Babel预设（Preset）就是一组Babel插件的集合，比如Babel 6.0中的 babel-preset-es2015 包含所有跟ES6转换有关的插件。如果没有预设，babel转化是需要指定用什么插件的，虽然颗粒度小，效率高，但是插件需要逐个安装，还有严格的配置声明顺序。本文后面不再深入叙述插件相关的概念，等有时间将写一篇文章进一步深入学习Babel的原理。 基础用法单独使用Babel@babel/core + @babel/cli + @babel/preset-envBabel 的核心功能包含在 @babel/core 模块中。通过以下命令安装： 1npm install --save-dev @babel/core 你也可以在 JavaScript 程序中直接 require 并使用它： 123const babel = require(\"@babel/core\");babel.transformSync(\"code\", optionsObject); 一般情况下，如果单独使用Babel来完成整个工作流，我们会借助@babel/cli实现在终端（命令行）中快速使用babel命令进行代码转换。 @babel/cli 是一个能够从终端（命令行）便捷使用@babel/core能力的工具。下面是其安装命令和基本用法： 123npm install --save-dev @babel/core @babel/cli./node_modules/.bin/babel src --out-dir lib 你可以利用 npm@5.2.0 所自带的 npm 包运行器将 ./node_modules/.bin/babel 命令缩短为 npx babel. 后文将使用npx方式执行，不再赘述 这将解析 src 目录下的所有 JavaScript 文件，并应用我们所指定的代码转换功能，然后把每个文件输出到 lib 目录下。由于我们还没有指定任何代码转换功能，所以输出的代码将与输入的代码相同（不保留原代码格式）。 实际场景中，我们还需要安装其他转换插件作为参数传递进去，将它们集成到 @babel/core 工作流程中，来实现我们所需的指定规则代码转换功能。我们将只使用 @babel/preset-env 这一个插件预设来实现我们的基础功能。 在上面的基础上，继续执行： 123npm install --save-dev @babel/preset-envnpx babel src --out-dir lib --presets=@babel/env 上面相比于之前的执行多了一个传参--presets=@babel/env，这将告诉 @babel/cli 使用 @babel/core 结合 @babel/preset-env 预设进行代码转换，在通过命令行传递 preset 时，我们也可以指定该 preset 的一些相关参数，对转换后的代码进行细节上的控制（例如可以控制转换后的JS代码版本需要支持哪些浏览器），但是因为这样的话命令会显得很长且十分繁琐，我们更喜欢将这些参数以JSON的格式存放到一个固定的配置文件中。 现在，我们首先创建一个名为 babel.config.json 的文件（需要 v7.8.0 或更高版本），并包含如下内容： 12345678910&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"targets\": \"&gt; 0.25%, not dead\" &#125; ] ]&#125; 该配置表示仅包含浏览器市场份额 &gt;0.25％ 的用户所需的代码转换。 官方也建议使用.browserslistrc文件来代替targets的配置： 12&gt; 0.25%not dead 或者package.json： 123&#123; &quot;browserslist&quot;: &quot;&gt; 0.25%, not dead&quot;&#125; 有了上述配置文件之后，我们只需要这么执行就可以了： 1npx babel src --out-dir lib Babel支持更多的配置方式，详见配置 Babel，目前来说我们这么用就可以了。 结合Webpack使用Babel实际项目中单独使用Babel的命令行工具来实现工作流的情况不是很多，更多的是结合Webpack使用。 在webpack.config.js中添加以下loader配置： 123456789101112131415161718module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: [ &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&quot;@babel/preset-env&quot;] &#125; &#125; ] &#125; ] &#125;&#125; 然后安装相应的依赖：babel-loader、@babel/core、@babel/preset-env: 1npm install --save-dev babel-loader @babel/core @babel/preset-env 上面是将babel的preset参数配置在了webpack.config.js中，实际上也可以将它按照babel配置文件的原则提取出来单独一个babel.config.json文件，效果是一样的。 这样就完成了在webpack项目中添加Babel转换ES6+代码的功能。在webpack打包的过程中，会将源代码经由babel-loader处理转换为目标代码，这一执行过程对我们来只说是打包时“顺势而为”的，我们再也不用关心Babel本身的命令细节了。","tags":[{"name":"Babel","slug":"Babel","permalink":"//linyk.me/tags/Babel/"}]},{"title":"从VDOM切入浅谈Vue的框架设计思想","date":"2019-08-18T02:27:00.000Z","path":"2019/08/18/vue-s-frame-design-idea/","text":"文章开始先简单介绍VDOM的概念。VDOM全称是Virtual DOM，即虚拟DOM。本质上是一个树形数据结构的JS Object，该树形结构的每个对象节点都包含有一些key-value，如标签名、Attributes、节点内容等，类比于真实DOM节点所具有的属性。那么VDOM的作用是什么？ 技术最终都是为业务而服务的，VDOM也不过是一种技术手段，用于下面解决这种场景： 随着时间的推移，在项目业务代码日益庞大复杂的情况下，巨量的DOM操作代码难以进行手工优化，存在许多不必要的DOM操作损耗，常常触发大面积的页面更新，引起大面积重绘甚至回流，而需求可能只是想要更新某个组件下的某个文本节点，却刷新了整个组件......最终项目不堪重负，难以维护。 基于这种情况，最先想到的是方案是封装一个库，使用createDocumentFragment创建一个目标DOM片段，然后和现有的DOM进行比较（Diff），找出实际需要更新的节点，再把实际节点渲染到文档中。但是这种方案问题依然存在，因为遍历DOM进行diff本身就是一个开销巨大的事情。于是乎，VDOM出现了。 众所周知DOM操作相对于纯JS执行来说，是十分慢的【1】。因此VDOM的作用就是取代这个真实`DOM Diff`过程，改为`VDOM Diff`，从操作DOM改成操作JS Object，速度大大提升！ VDOM的实现并不比经过优化的手动直接操作DOM更快，原因在于其还有额外的Diff算法损耗；但好处在于它有更好的可维护性的同时还能提供不错的性能，毕竟人力无法永远保持高度的专注力去优化繁杂的业务逻辑代码。 VDOM的主流表现形式之一是JSX，JSX的写法和JS一样动态灵活，非常适合构建复杂的应用，但这种灵活也因此产生了一个短板：正是因为JS代码写法多变，使得框架内部无法安全精准地预判需要更新的具体地方，因此需要一轮树型Diff的遍历，才敢保证安全地触发局部更新。 模板是VDOM实现的另外一种表现形式，优点是写法有规则，受约束，结构清晰直观；相对的缺点就是灵活性不足，在某些极端场景下难以完整发挥JS的能力，会让人感到“憋屈”。 综上对比，纯JSX表现的VDOM实现会存在一个问题，即依赖的运行时代码逻辑要多一些，因为为了能做出更多的DOM更新优化（毕竟DOM性能损耗才是大头），需要考虑的东西更多以保证性能，因此打包后代码量也会大一些。而纯模板实现的优缺点也是很明显的，由于代码写法都在规则之内，因此可以在优化时做出更多的预判，而预判优化是可以放在预编译阶段完成的，因此也使得运行时代码相对少些，但是，模板实现形式的不灵活性是个硬伤，在应对某些复杂业务上偶尔会余力不足。 Vue将模板形式和JSX形式两种都支持了，据我所知最开始的主流模板渲染形式和VDOM Diff算法并没有结合起来，正是由于Vue才让两者之间优点结合并发扬光大（也有可能是我孤陋寡闻…）。 事实上Vue性能也许不是最好的，但在框架设计考虑这块深得我心。在Vue3.0中，虽然出了新的写法且变化巨大一时难以适应，但据说在模板的VDOM Diff算法上的改进很大，由于模板的优点，使得Vue可以划分静态节点（如纯文本节点）和动态节点（数据绑定节点），而静态节点实际上是不需要Diff的，这也使得Vue在很多场景下只对动态节点做diff，此时原有的树型diff可能就扁平化成数组diff，大大降低了模板VDOM Diff的性能损耗，因此Vue3.0值得期待。 在框架设计过程中的权衡和考量，Vue综合吸取了Angular在系统应用层面上的“全”和React在底层扩展灵活方便上的“细”，在学习上更加简单，不必一开始便掌握大量暂时使用不到的概念，并且也可以循序渐进逐步学习、安装和使用其他功能“配件”，因此官方称其为“渐进式”Javascript框架，这也是我最喜欢的一点。 【1】： JS本身并不具备DOM，只有DOM操作能力，而DOM是浏览器提供的。DOM的渲染和JS的执行分属两个不同的线程，因此JS操作DOM实际上是线程之间的通信，也因此代价要比JS本身的执行要高得多。","tags":[{"name":"VDOM","slug":"VDOM","permalink":"//linyk.me/tags/VDOM/"},{"name":"Vue","slug":"Vue","permalink":"//linyk.me/tags/Vue/"}]},{"title":"Javascript呈现星星评分效果的最简单实现","date":"2017-10-13T07:30:28.000Z","path":"2017/10/13/stars-score/","text":"今天群里聊到星星评分实现的需求，突然想起来以前看过此类的一个超简单实现，花了几分钟思考重现了这一小段代码： 12345678/* * score为分值，范围为0-5 */function stars(score)&#123; return \"★★★★★☆☆☆☆☆\".substr(5 - score, 5);&#125;stars(3); //★★★☆☆","tags":[{"name":"Javascript","slug":"Javascript","permalink":"//linyk.me/tags/Javascript/"}]},{"title":"排序算法：Javascript实现冒泡排序","date":"2017-06-05T12:05:38.000Z","path":"2017/06/05/bubble-sort/","text":"一、冒泡原理按从小到大排列顺序的实现来举例，冒泡的过程是指： 从第一个数开始，相邻两个数之间比较，将较大的数记为a；若a处于后者则顺序不变动，不是处于后者则将其与对比的较小的数调换（如同“往上”冒一个泡）；然后重新比较a的值和其后面一位数的大小，将较大的数重新设为a，再次使a“冒泡”；反复往后比较并“冒泡”，直到a到达数列底部（“水面”）； 以上为一次冒泡过程，得到了一个最大值，然后继续开始第二次冒泡过程，这时只需要在排除最后一个数（已排序成功的最大值）的子数列中进行冒泡，同理将第一个数冒泡至该子数列底部。 …… 重复上述冒泡循环，直到倒数第二个数冒泡完成（倒数第二个数排序完成，则剩下的最后一个数顺序也就确定了），假设数列一共有n个数，则需要进行n-1次循环的冒泡过程。 每次冒泡过程的具体逻辑都是一致的，也是一个循环，即随着当前（子）数列索引j（假设从0开始）的递增，循环判断相邻的两项大小（进行冒泡），直到当前索引j等于当前（子）数列个数减1（注意“当前”的冒泡数列的长度是递减的）。 二、算法实现根据以上逻辑，我们可以写出以下的代码实现（i值循环递减的写法）： 123456789101112131415161718192021var arr = [3, 1, 5, 0, 5, 8, 2, 7, 9];function bubbleSort(arr)&#123; var len = arr.length; for(var i=len-1; i&gt;0;i--)&#123; for(var j=0;j&lt;i;j++)&#123; // 由小到大用 &gt;， 由大到小就是 &lt; if(arr[j] &gt; arr[j+1])&#123; var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125;&#125;bubbleSort(arr); // [0, 1, 2, 3, 5, 5, 7, 8, 9] 还有另外一种写法，也放出来供对比一下（i值循环递增的写法）： 123456789101112131415161718192021var arr = [3, 1, 5, 0, 5, 8, 2, 7, 9];function bubbleSort(arr)&#123; var len = arr.length; for(var i=0; i&lt;len-1;i++)&#123; for(var j=0;j&lt;len-1-i;j++)&#123; // 由小到大用 &gt;， 由大到小就是 &lt; if(arr[j] &gt; arr[j+1])&#123; var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125;&#125;bubbleSort(arr); // [0, 1, 2, 3, 5, 5, 7, 8, 9] 两种方式都可以，看各人喜好吧 :p","tags":[{"name":"排序算法","slug":"排序算法","permalink":"//linyk.me/tags/排序算法/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"//linyk.me/tags/冒泡排序/"}]},{"title":"new Date解析日期字符串在不同浏览器的差异","date":"2017-03-31T02:42:35.000Z","path":"2017/03/31/chrome-date-bug/","text":"今天，偶然发现一个Chrome对于执行new Date()表达式产生的怪异现象，如下所示： Chrome F12控制台 123new Date(\"2017-03-31\"); //打印： Fri Mar 31 2017 08:00:00 GMT+0800 (中国标准时间)new Date(\"2017-3-31\"); //打印： Fri Mar 31 2017 00:00:00 GMT+0800 (中国标准时间) 即在这种情况下，输出的结果差别是08时和00时。而在其他浏览器是这样的： Firefox控制台 12345new Date(\"2017-03-31\"); //打印： 2017-03-31T00:00:00.000Znew Date(\"2017-3-31\"); //打印： 2017-03-31T00:00:00.000Z//结果一致 IE控制台模拟：IE 9 123new Date(\"2017-03-31\"); //打印： Fri Mar 31 08:00:00 UTC+0800 2017 new Date(\"2017-3-31\"); //打印： Invalid Date IE控制台模拟：IE 7/8 123new Date(\"2017-03-31\"); //打印： NaN new Date(\"2017-3-31\"); //打印： NaN 可以看到，Firefox得到的结果应该是和我们期望的一样，而IE……一如既往的给予我们惊喜。 总结：new Date对于日期字符串的解析因浏览器而异，为了保持最大兼容性的统一，建议使用以下格式： 123new Date(yyyy,mth,dd,hh,mm,ss); //精确到秒 new Date(yyyy,mth,dd); //精确到天 注意：以上的mth值为现实世界月份-1。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"//linyk.me/tags/Javascript/"}]},{"title":"Babel 6.0之babel-cli和babel-core的用法和区别","date":"2017-03-30T22:12:52.000Z","path":"2017/03/31/babel-usage/","text":"在Babel 6以前，Babel是一个专注且单一的Javascript转换器，然而Babel团队的志向不仅于此，更想把Babel打造成一个平台，由各个不同的功能模块和可插拔插件组成，用于创建下一代JavaScript工具集。 于是Babel 6发布了。 Babel 6本身不具有转换ES6代码的功能，也不再默认内嵌支持JSX语法，这一切都需要通过安装对应的转换器插件来实现。 在此之前，Babel囊括了整个编译器、所有的转换器以及一个CLI工具， 虽然方便使用，这么做的缺点就是它会导致很多不必要的下载。现在，Bable不再是一个整体包了，它分为了两个单独的包，babel-cli和babel-core。此外还有一些插件预设，如babel-preset-es2015、babel-preset-react等。 如果你想要在命令行使用Babel，你可以安装babel-cli 如果你需要在一个Node项目中使用Babel，你可以使用babel-core 参考：走进Babel 6.0 全新特性解析","tags":[]},{"title":"使用Hexo，如何在多台电脑上维护和更新github pages博客","date":"2017-03-23T21:51:40.000Z","path":"2017/03/24/hexo-github-pages/","text":"今天在公司用hexo搭好博客之后，突然有个疑问：我想要回到家继续写文章，那换了电脑之后该怎么更新博客呢？ 思路：使用git分支。 即用个人博客仓库的master分支来保存博客静态页面，新建另一个分支来保存hexo部署环境目录！之后每次博客的更新就在新分支上编辑和发布（deploy），把生成的博客页面推到master分支上。 话不多说，下面是我实践的方法（前四步是在公司电脑上，第五步是家里的电脑）： 一、准备工作开始本教程之前，请确保你已经使用hexo在github pages上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录（博客根目录）： 如果这一步还未完成，请自行搜索如何使用hexo搭建Github Pages个人博客，网上教程一大堆，不再赘述。 二、对username.github.io仓库新建分支，并克隆在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆到本地，进入该username.github.io文件目录。 完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支xxx： 12$ git branch*xxx 三、将本地博客的部署文件拷贝进username.github.io文件目录如题，先将本地博客的部署文件全部拷贝进username.github.io文件目录。 接下来，将拷贝进来的博客hexo部署环境提交到xxx分支，提交之前需注意： 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 四、提交xxx分支执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。 现在可以在GitHub上的username.github.io仓库看到两个分支的差异了。 master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！ 五、新电脑环境部署和更新至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下) 尽情地敲击键盘、挥洒笔墨吧！ 编辑、撰写文章或其他博客更新改动 依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证xxx分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 注意：每次换电脑进行博客更新时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先git pull获取xxx分支的最新版本，之后再进行编辑和提交。","tags":[{"name":"hexo","slug":"hexo","permalink":"//linyk.me/tags/hexo/"}]},{"title":"转载：彻底理解JavaScript的同步、异步和事件循环(Event Loop)","date":"2017-03-23T07:07:07.000Z","path":"2017/03/23/js-event-loop/","text":"一. 单线程我们常说“JavaScript是单线程的”。 所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。 但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。 二. 同步和异步假设存在一个函数A：1A(args...); 同步：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 例如： 12Math.sqrt(2);console.log('Hi'); 第一个函数返回时，就拿到了预期的返回值：2的平方根。 第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。 所以这两个函数都是同步的。 异步：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 例如：123fs.readFile('foo.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;); 在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。 下面以AJAX请求为例，来看一下同步和异步的区别： 异步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。” 主线程：：“谢谢，你拿到响应后告诉我一声啊。” (接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。) 同步AJAX： 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。” AJAX线程：“……” 主线程：：“喂，AJAX线程，你怎么不说话？” AJAX线程：“……” 主线程：：“喂！喂喂喂！” AJAX线程：“……” (一炷香的时间后) 主线程：：“喂！求你说句话吧！” AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。” 正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。异步是这篇文章关注的重点。 三. 异步过程的构成要素从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。 总结一下，一个异步过程通常是这样的： 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。 异步函数通常具有以下的形式： 1A(args..., callbackFn) 它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。args是这个函数需要的参数。callbackFn也是这个函数的参数，但是它比较特殊所以单独列出来。 所以，从主线程的角度看，一个异步过程包括下面两个要素： 发起函数(或叫注册函数)A 回调函数callbackFn 它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。 举个具体的例子： 1setTimeout(fn, 1000); 其中的setTimeout就是异步过程的发起函数，fn是回调函数。 注意：前面说的形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如： 1234var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open('GET', url);xhr.send(); // 发起函数 发起函数和回调函数就是分离的。 四. 消息队列和事件循环上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制是怎样实现的呢？答案是利用消息队列和事件循环。 用一句话概括： *工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。 事件循环用代码表示大概是这样的： 1234while(true) &#123; var message = queue.get(); execute(message);&#125; 那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为： 消息就是注册异步任务时添加的回调函数。再次以异步AJAX为例，假设存在如下的代码： 12345678$.ajax('http://segmentfault.com', function(resp) &#123; console.log('我是响应：', resp);&#125;);// 其他代码......... 主线程在发起AJAX请求后，会继续执行其他代码。AJAX线程负责请求segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息： 1234// 消息队列中的消息就长这个样子var message = function () &#123; callbackFn(response);&#125; 其中的callbackFn就是前面代码中得到成功响应时的回调函数。 主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。 用图表示这个过程就是： 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 五. 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。 举例来说： 1234var button = document.getElement('#btn');button.addEventListener('click', function(e) &#123; console.log();&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。 另一方面，所有的异步过程也都可以用事件来描述。例如：setTimeout可以看成对应一个时间到了！的事件。前文的setTimeout(fn, 1000);可以看成： 1timer.addEventListener('timeout', 1000, fn); 六. 生产者与消费者从生产者与消费者的角度看，异步过程是这样的： 工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。 七. 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些 :) PS：ECMAScript 262规范中，并没有对异步、事件队列等概念及其实现的描述。这些都是具体的JavaScript运行时环境使用的机制。本文重点是描述异步过程的原理，为了便于理解做了很多简化。所以文中的某些术语的使用可能是不准确的，具体细节也未必是正确的，例如消息队列中消息的结构。请读者注意。 PS:本文转载自 https://segmentfault.com/a/1190000004322358","tags":[{"name":"Javascript","slug":"Javascript","permalink":"//linyk.me/tags/Javascript/"}]}]